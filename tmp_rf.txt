import 'dart:convert';
import 'package:flutter/material.dart';
import '../models/ingredient_model.dart';
import '../models/refrigerator_model.dart';
import '../common/api_client.dart';
import 'package:intl/intl.dart';
import 'dart:io';
import 'package:shared_preferences/shared_preferences.dart';
import '../services/ocr_service.dart';

class RefrigeratorViewModel with ChangeNotifier {
  final ApiClient _apiClient = ApiClient();
  List<Refrigerator> _refrigerators = [];
  Map<int, List<Ingredient>> _ingredientMap = {};
  int _selectedIndex = 0;
  bool _isLoading = false;
  String? _errorMessage;
  List<String> _categories = [
    '梨꾩냼',
    '怨쇱씪',
    '?〓쪟',
    '?댄뙣瑜?,
    '?좎젣??,
    '媛怨듭떇??,
    '?뚮즺',
    '怨〓Ъ',
    '湲고?',
  ];

  final OcrService _ocrService = OcrService();
  List<Ingredient> _scannedIngredients = [];
  String? _ocrErrorMessage;

  // --- Getters ---
  int get selectedIndex => _selectedIndex;
  bool get isLoading => _isLoading;
  String? get errorMessage => _errorMessage;
  List<Refrigerator> get refrigerators => _refrigerators;
  List<String> get categories => _categories;
  List<Ingredient> get scannedIngredients => _scannedIngredients;
  String? get ocrErrorMessage => _ocrErrorMessage;

  List<Ingredient> get ingredients {
    if (_refrigerators.isEmpty) return [];
    final selectedRefrigeratorId = _refrigerators[_selectedIndex].id;
    final ingredients = _ingredientMap[selectedRefrigeratorId] ?? [];
    ingredients.sort((a, b) => a.expiryDate.compareTo(b.expiryDate));
    return ingredients;
  }

  List<Ingredient> get userIngredients =>
      _ingredientMap.values.expand((list) => list).toList();
  // --- Constructor ---
  RefrigeratorViewModel() {}

  Future<void> loadInitialData() {
    return fetchRefrigerators();
  }

  // --- Data Fetching & State Update ---
  Future<void> fetchRefrigerators() async {
    _isLoading = true;
    _errorMessage = null;
    notifyListeners();

    try {
      final response = await _apiClient.get('/api/refrigerators');
      if (response.statusCode == 200) {
        final List<dynamic> responseData = jsonDecode(
          utf8.decode(response.bodyBytes),
        );
        _refrigerators = responseData
            .map((data) => Refrigerator.fromJson(data))
            .toList();
        _selectedIndex = _refrigerators.indexWhere(
          (r) => r.type == RefrigeratorType.main,
        );
        if (_selectedIndex == -1 && _refrigerators.isNotEmpty)
          _selectedIndex = 0;
        if (_refrigerators.isNotEmpty) {
          await fetchAllIngredients();
        }
      } else {
        _errorMessage = '?됱옣怨?紐⑸줉 濡쒕뵫 ?ㅽ뙣';
      }
    } catch (e) {
      _errorMessage = '?됱옣怨?紐⑸줉 濡쒕뵫 以??ㅻ쪟 諛쒖깮';
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  Future<void> fetchAllIngredients() async {
    _ingredientMap = {};
    for (var fridge in _refrigerators) {
      await _fetchIngredientsForId(fridge.id);
    }
    _updateCategories();
    await _cacheIngredientsForNotifications();
    notifyListeners();
  }

  Future<void> _fetchIngredientsForId(int refrigeratorId) async {
    try {
      final response = await _apiClient.get(
        '/api/refrigerators/$refrigeratorId/items',
      );
      if (response.statusCode == 200) {
        final List<dynamic> responseData = jsonDecode(
          utf8.decode(response.bodyBytes),
        );
        _ingredientMap[refrigeratorId] = responseData
            .map((data) => Ingredient.fromJson(data, refrigeratorId))
            .toList();
      }
    } catch (e) {
      _ingredientMap[refrigeratorId] = [];
    }
  }

  void _updateCategories() {
    final allIngredients = _ingredientMap.values.expand((list) => list).toList();
    final categorySet = allIngredients.map((i) => i.category).toSet();
    _categories = categorySet.toList()..sort();
  }

  Future<void> _cacheIngredientsForNotifications() async {
    try {
      final all = _ingredientMap.values.expand((list) => list).toList();
      final data = all.map((i) => {
        'id': i.id,
        'name': i.name,
        'expiryDate': i.expiryDate.toIso8601String(),
      }).toList();
      final prefs = await SharedPreferences.getInstance();
      await prefs.setString('cached_ingredients', jsonEncode(data));
    } catch (_) {
      // ignore caching errors
    }
  }

  // --- UI Control ---
  Future<void> selectRefrigerator(int index) async {
    _selectedIndex = index;
    notifyListeners();
  }

  void changeRefrigeratorImage(int index, String newImage) {
    _refrigerators[index].currentImage = newImage;
    notifyListeners();
  }

  // --- CRUD Methods ---
  Future<bool> addIngredient(Ingredient newIngredient) async {
    try {
      // First attempt with selected category as-is
      final Map<String, dynamic> body = newIngredient.toJson();
      var response = await _apiClient.post(
        '/api/refrigerators/${newIngredient.refrigeratorId}/items',
        body: body,
      );

      // If the server rejects due to enum/category mismatch, try a safe fallback
      if (response.statusCode != 201) {
        final fb = _fallbackCategoryIfNeeded(body['category'] as String);
        if (fb != null) {
          final retryBody = Map<String, dynamic>.from(body)..['category'] = fb;
          response = await _apiClient.post(
            '/api/refrigerators/${newIngredient.refrigeratorId}/items',
            body: retryBody,
          );
        }
      }

      if (response.statusCode == 201) {
        await fetchAllIngredients();
        return true;
      }
      // Leave a hint in logs to diagnose quickly
      // ignore: avoid_print
      print('addIngredient failed: ${response.statusCode} ${response.body}');
      return false;
    } catch (e) {
      // ignore: avoid_print
      print('addIngredient exception: $e');
      return false;
    }
  }

  // Returns an alternative category string if known mismatches are detected
  String? _fallbackCategoryIfNeeded(String category) {
    switch (category.trim()) {
      case '怨〓Ъ':
        // Some backends use '怨〓쪟' instead of '怨〓Ъ'
        return '怨〓쪟';
      case '?묐뀗':
        return '議곕?猷?;
      case '?뚯뒪':
        return '議곕?猷?;
    }
    return null;
  }

  Future<bool> updateIngredient(Ingredient ingredientToUpdate) async {
    try {
      // [?섏젙] 蹂대궡二쇱떊 肄붾뱶??body ?앹꽦 濡쒖쭅???ㅼ떆 諛섏쁺?덉뒿?덈떎.
      final body = {
        'name': ingredientToUpdate.name,
        'expiryDate': DateFormat(
          'yyyy-MM-dd',
        ).format(ingredientToUpdate.expiryDate),
        'quantity': ingredientToUpdate.quantity,
        'category': ingredientToUpdate.category,
        'refrigeratorId': ingredientToUpdate.refrigeratorId,
        'iconIndex': ingredientToUpdate.iconIndex,
      };
      var response = await _apiClient.put('/api/items/4{ingredientToUpdate.id}', body: body, );\n      if (response.statusCode != 200) {\n        final fb = _fallbackCategoryIfNeeded(body['category'] as String);\n        if (fb != null) {\n          final retryBody = Map<String, dynamic>.from(body)..['category'] = fb;\n          response = await _apiClient.put('/api/items/4{ingredientToUpdate.id}', body: retryBody, );\n        }\n      }
      if (response.statusCode == 200) {
        await fetchAllIngredients();
        return true;
      }
      return false;
    } catch (e) {
      return false;
    }
  }


  Future<bool> deleteIngredient(int id) async {
    try {
      final response = await _apiClient.delete('/api/items/$id');
      if (response.statusCode == 200 || response.statusCode == 204) {
        await fetchAllIngredients();
        return true;
      }
      return false;
    } catch (e) {
      return false;
    }
  }

  // [異붽?] OCR ?ㅼ틪 ?쒖옉 硫붿냼??
  Future<bool> startOcrScan(File imageFile) async {
    _isLoading = true;
    _ocrErrorMessage = null;
    notifyListeners();

    try {
      final itemNames = await _ocrService.scanReceipt(imageFile);
      if (itemNames.isEmpty) {
        _ocrErrorMessage = "?곸닔利앹뿉???앹옱猷뚮? 李얠? 紐삵뻽?댁슂.\n?ㅻⅨ ?ъ쭊?쇰줈 ?쒕룄?대낫?몄슂.";
        return false;
      }

      // OCR 寃곌낵(臾몄옄??由ъ뒪??瑜?Ingredient 媛앹껜 由ъ뒪?몃줈 蹂??
      final defaultExpiryDate = DateTime.now().add(const Duration(days: 7));
      final defaultRefrigeratorId = refrigerators[selectedIndex].id;

      _scannedIngredients = itemNames
          .map(
            (name) => Ingredient(
              id: 0, // ?꾩떆 ID
              name: name,
              expiryDate: defaultExpiryDate,
              quantity: 1, // 湲곕낯 ?섎웾 1
              registrationDate: DateTime.now(),
              category: '湲고?', // 湲곕낯 移댄뀒怨좊━
              refrigeratorId: defaultRefrigeratorId,
            ),
          )
          .toList();

      return true;
    } catch (e) {
      _ocrErrorMessage = e.toString();
      return false;
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  // [異붽?] ?ㅼ틪???щ즺 紐⑸줉 ?꾩껜 ???
  Future<bool> addAllScannedIngredients() async {
    _isLoading = true;
    notifyListeners();

    bool allSuccess = true;
    for (var ingredient in _scannedIngredients) {
      final success = await addIngredient(ingredient);
      if (!success) {
        allSuccess = false;
        // ?ㅽ뙣 ??泥섎━ (?? ?ъ슜?먯뿉寃??뚮┝)
      }
    }

    _scannedIngredients.clear(); // ?꾩떆 紐⑸줉 鍮꾩슦湲?
    _isLoading = false;
    notifyListeners();

    // 紐⑤뱺 ?щ즺媛 異붽????? ?꾩옱 ?됱옣怨좎쓽 ?щ즺 紐⑸줉???쒕쾲 ??媛깆떊
    await _fetchIngredientsForId(refrigerators[selectedIndex].id);
    return allSuccess;
  }
}





